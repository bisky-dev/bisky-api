// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: episodes.sql

package sqlc

import (
	"context"
)

const createEpisode = `-- name: CreateEpisode :one
INSERT INTO episodes (
  show_id,
  season_number,
  episode_number,
  title,
  air_date,
  runtime_minutes,
  external_ids
)
VALUES ($1::uuid, $2, $3, $4, $5, $6, $7)
RETURNING
  internal_episode_id,
  show_id,
  season_number,
  episode_number,
  title,
  air_date,
  runtime_minutes,
  external_ids,
  created_at,
  updated_at
`

type CreateEpisodeParams struct {
	ShowID         string
	SeasonNumber   int64
	EpisodeNumber  int64
	Title          string
	AirDate        *string
	RuntimeMinutes *int64
	ExternalIds    []byte
}

func (q *Queries) CreateEpisode(ctx context.Context, arg CreateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, createEpisode,
		arg.ShowID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.AirDate,
		arg.RuntimeMinutes,
		arg.ExternalIds,
	)
	var i Episode
	err := row.Scan(
		&i.InternalEpisodeID,
		&i.ShowID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.RuntimeMinutes,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEpisode = `-- name: DeleteEpisode :one
DELETE FROM episodes
WHERE internal_episode_id = $1::uuid
RETURNING internal_episode_id
`

func (q *Queries) DeleteEpisode(ctx context.Context, internalEpisodeID string) (string, error) {
	row := q.db.QueryRow(ctx, deleteEpisode, internalEpisodeID)
	var deletedID string
	err := row.Scan(&deletedID)
	return deletedID, err
}

const getEpisodeByID = `-- name: GetEpisodeByID :one
SELECT
  internal_episode_id,
  show_id,
  season_number,
  episode_number,
  title,
  air_date,
  runtime_minutes,
  external_ids,
  created_at,
  updated_at
FROM episodes
WHERE internal_episode_id = $1::uuid
LIMIT 1
`

func (q *Queries) GetEpisodeByID(ctx context.Context, internalEpisodeID string) (Episode, error) {
	row := q.db.QueryRow(ctx, getEpisodeByID, internalEpisodeID)
	var i Episode
	err := row.Scan(
		&i.InternalEpisodeID,
		&i.ShowID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.RuntimeMinutes,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEpisodes = `-- name: ListEpisodes :many
SELECT
  internal_episode_id,
  show_id,
  season_number,
  episode_number,
  title,
  air_date,
  runtime_minutes,
  external_ids,
  created_at,
  updated_at
FROM episodes
ORDER BY created_at DESC
`

func (q *Queries) ListEpisodes(ctx context.Context) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.InternalEpisodeID,
			&i.ShowID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.AirDate,
			&i.RuntimeMinutes,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEpisodesByShowID = `-- name: ListEpisodesByShowID :many
SELECT
  internal_episode_id,
  show_id,
  season_number,
  episode_number,
  title,
  air_date,
  runtime_minutes,
  external_ids,
  created_at,
  updated_at
FROM episodes
WHERE show_id = $1::uuid
ORDER BY season_number ASC, episode_number ASC
`

func (q *Queries) ListEpisodesByShowID(ctx context.Context, showID string) ([]Episode, error) {
	rows, err := q.db.Query(ctx, listEpisodesByShowID, showID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Episode{}
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.InternalEpisodeID,
			&i.ShowID,
			&i.SeasonNumber,
			&i.EpisodeNumber,
			&i.Title,
			&i.AirDate,
			&i.RuntimeMinutes,
			&i.ExternalIds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpisode = `-- name: UpdateEpisode :one
UPDATE episodes
SET
  show_id = $2::uuid,
  season_number = $3,
  episode_number = $4,
  title = $5,
  air_date = $6,
  runtime_minutes = $7,
  external_ids = $8,
  updated_at = NOW()
WHERE internal_episode_id = $1::uuid
RETURNING
  internal_episode_id,
  show_id,
  season_number,
  episode_number,
  title,
  air_date,
  runtime_minutes,
  external_ids,
  created_at,
  updated_at
`

type UpdateEpisodeParams struct {
	InternalEpisodeID string
	ShowID            string
	SeasonNumber      int64
	EpisodeNumber     int64
	Title             string
	AirDate           *string
	RuntimeMinutes    *int64
	ExternalIds       []byte
}

func (q *Queries) UpdateEpisode(ctx context.Context, arg UpdateEpisodeParams) (Episode, error) {
	row := q.db.QueryRow(ctx, updateEpisode,
		arg.InternalEpisodeID,
		arg.ShowID,
		arg.SeasonNumber,
		arg.EpisodeNumber,
		arg.Title,
		arg.AirDate,
		arg.RuntimeMinutes,
		arg.ExternalIds,
	)
	var i Episode
	err := row.Scan(
		&i.InternalEpisodeID,
		&i.ShowID,
		&i.SeasonNumber,
		&i.EpisodeNumber,
		&i.Title,
		&i.AirDate,
		&i.RuntimeMinutes,
		&i.ExternalIds,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
