// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repos.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRepo = `-- name: CreateRepo :one
INSERT INTO repos (org, name, github_id, html_url, description, is_private, default_branch, user_id, repo_category_id, github_org_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, org, name, github_id, html_url, description, is_private, default_branch, user_id, repo_category_id, github_org_id, created_at, updated_at
`

type CreateRepoParams struct {
	Org            string
	Name           string
	GithubID       pgtype.Int8
	HtmlUrl        *string
	Description    *string
	IsPrivate      bool
	DefaultBranch  string
	UserID         *string
	RepoCategoryID *string
	GithubOrgID    *string
}

type CreateRepoRow struct {
	ID             string
	Org            string
	Name           string
	GithubID       pgtype.Int8
	HtmlUrl        *string
	Description    *string
	IsPrivate      bool
	DefaultBranch  string
	UserID         *string
	RepoCategoryID *string
	GithubOrgID    *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) CreateRepo(ctx context.Context, arg CreateRepoParams) (CreateRepoRow, error) {
	row := q.db.QueryRow(ctx, createRepo,
		arg.Org,
		arg.Name,
		arg.GithubID,
		arg.HtmlUrl,
		arg.Description,
		arg.IsPrivate,
		arg.DefaultBranch,
		arg.UserID,
		arg.RepoCategoryID,
		arg.GithubOrgID,
	)
	var i CreateRepoRow
	err := row.Scan(
		&i.ID,
		&i.Org,
		&i.Name,
		&i.GithubID,
		&i.HtmlUrl,
		&i.Description,
		&i.IsPrivate,
		&i.DefaultBranch,
		&i.UserID,
		&i.RepoCategoryID,
		&i.GithubOrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRepo = `-- name: DeleteRepo :exec
DELETE FROM repos
WHERE id = $1
`

func (q *Queries) DeleteRepo(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteRepo, id)
	return err
}

const getRepoByID = `-- name: GetRepoByID :one
SELECT id, org, name, github_id, html_url, description, is_private, default_branch, user_id, repo_category_id, github_org_id, created_at, updated_at
FROM repos
WHERE id = $1
LIMIT 1
`

type GetRepoByIDRow struct {
	ID             string
	Org            string
	Name           string
	GithubID       pgtype.Int8
	HtmlUrl        *string
	Description    *string
	IsPrivate      bool
	DefaultBranch  string
	UserID         *string
	RepoCategoryID *string
	GithubOrgID    *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) GetRepoByID(ctx context.Context, id string) (GetRepoByIDRow, error) {
	row := q.db.QueryRow(ctx, getRepoByID, id)
	var i GetRepoByIDRow
	err := row.Scan(
		&i.ID,
		&i.Org,
		&i.Name,
		&i.GithubID,
		&i.HtmlUrl,
		&i.Description,
		&i.IsPrivate,
		&i.DefaultBranch,
		&i.UserID,
		&i.RepoCategoryID,
		&i.GithubOrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRepos = `-- name: ListRepos :many
SELECT id, org, name, github_id, html_url, description, is_private, default_branch, user_id, repo_category_id, github_org_id, created_at, updated_at
FROM repos
ORDER BY created_at DESC
`

type ListReposRow struct {
	ID             string
	Org            string
	Name           string
	GithubID       pgtype.Int8
	HtmlUrl        *string
	Description    *string
	IsPrivate      bool
	DefaultBranch  string
	UserID         *string
	RepoCategoryID *string
	GithubOrgID    *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) ListRepos(ctx context.Context) ([]ListReposRow, error) {
	rows, err := q.db.Query(ctx, listRepos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReposRow
	for rows.Next() {
		var i ListReposRow
		if err := rows.Scan(
			&i.ID,
			&i.Org,
			&i.Name,
			&i.GithubID,
			&i.HtmlUrl,
			&i.Description,
			&i.IsPrivate,
			&i.DefaultBranch,
			&i.UserID,
			&i.RepoCategoryID,
			&i.GithubOrgID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepo = `-- name: UpdateRepo :one
UPDATE repos
SET
  org = $2,
  name = $3,
  github_id = $4,
  html_url = $5,
  description = $6,
  is_private = $7,
  default_branch = $8,
  repo_category_id = $9,
  github_org_id = $10,
  updated_at = now()
WHERE id = $1
RETURNING id, org, name, github_id, html_url, description, is_private, default_branch, user_id, repo_category_id, github_org_id, created_at, updated_at
`

type UpdateRepoParams struct {
	ID             string
	Org            string
	Name           string
	GithubID       pgtype.Int8
	HtmlUrl        *string
	Description    *string
	IsPrivate      bool
	DefaultBranch  string
	RepoCategoryID *string
	GithubOrgID    *string
}

type UpdateRepoRow struct {
	ID             string
	Org            string
	Name           string
	GithubID       pgtype.Int8
	HtmlUrl        *string
	Description    *string
	IsPrivate      bool
	DefaultBranch  string
	UserID         *string
	RepoCategoryID *string
	GithubOrgID    *string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

func (q *Queries) UpdateRepo(ctx context.Context, arg UpdateRepoParams) (UpdateRepoRow, error) {
	row := q.db.QueryRow(ctx, updateRepo,
		arg.ID,
		arg.Org,
		arg.Name,
		arg.GithubID,
		arg.HtmlUrl,
		arg.Description,
		arg.IsPrivate,
		arg.DefaultBranch,
		arg.RepoCategoryID,
		arg.GithubOrgID,
	)
	var i UpdateRepoRow
	err := row.Scan(
		&i.ID,
		&i.Org,
		&i.Name,
		&i.GithubID,
		&i.HtmlUrl,
		&i.Description,
		&i.IsPrivate,
		&i.DefaultBranch,
		&i.UserID,
		&i.RepoCategoryID,
		&i.GithubOrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
